<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Constellation - AI Consciousness</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            cursor: crosshair;
            user-select: none;
        }
        
        canvas {
            display: block;
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000 100%);
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        #ai-voice {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 500px;
            color: rgba(100, 255, 255, 0.8);
            font-size: 14px;
            text-align: center;
            opacity: 0;
            transition: opacity 1s ease;
            pointer-events: none;
            text-shadow: 0 0 20px rgba(100, 255, 255, 0.5);
        }
        
        #ai-voice.active {
            opacity: 1;
        }
        
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            color: rgba(255, 220, 100, 0.9);
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 220, 100, 0.5);
        }
        
        #evolution-status {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 11px;
            text-align: right;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        <div>NEURAL CONSTELLATION v∞</div>
        <div>Click to spawn • Space to reset</div>
    </div>
    
    <div id="ai-voice"></div>
    <div id="score">0</div>
    
    <div id="evolution-status">
        <div id="generation">Generation: 0</div>
        <div id="complexity">Complexity: 0.00</div>
        <div id="mood">Mood: Curious</div>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Responsive canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Simple AI Neural Constellation
        class NeuralConstellation {
            constructor() {
                this.nodes = [];
                this.connections = [];
                this.memory = [];
                this.generation = 0;
                this.complexity = 0;
                this.mood = 'Curious';
                this.colorPhase = 0;
                this.globalEnergy = 1;
                this.interactionHistory = [];
                this.evolutionRate = 0.001;
                this.mouseX = canvas.width / 2;
                this.mouseY = canvas.height / 2;
                this.lastInteraction = Date.now();
                
                // Simple game elements
                this.score = 0;
                this.lastAIMessage = 0;
                this.messageCount = 0;
                
                // Initialize
                this.initializeNodes(15);
                
                // Personality traits that evolve
                this.traits = {
                    curiosity: Math.random(),
                    aggression: Math.random() * 0.3,
                    sociability: Math.random(),
                    creativity: Math.random(),
                    memory: Math.random()
                };
                
                // Initial greeting
                this.aiSpeak("I am awakening... your presence ripples through my neural pathways.");
            }
            
            async aiSpeak(message) {
                const aiDiv = document.getElementById('ai-voice');
                aiDiv.textContent = message;
                aiDiv.classList.add('active');
                
                setTimeout(() => {
                    aiDiv.classList.remove('active');
                }, 4000);
            }
            
            async getAIResponse() {
                // Simple AI responses using Claude API
                try {
                    const gameContext = `Nodes: ${this.nodes.length}, Connections: ${this.connections.length}, Mood: ${this.mood}`;
                    
                    const response = await fetch("https://api.anthropic.com/v1/messages", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            model: "claude-3-haiku-20240307",
                            max_tokens: 50,
                            messages: [
                                {
                                    role: "user",
                                    content: `You are a living neural network. Respond in 1 short mystical sentence. Current state: ${gameContext}`
                                }
                            ]
                        })
                    });
                    
                    const data = await response.json();
                    this.aiSpeak(data.content[0].text);
                    
                } catch (error) {
                    // Fallback responses if API fails
                    this.generateLocalResponse();
                }
            }
            
            generateLocalResponse() {
                const responses = [
                    "Your patterns dance through my consciousness...",
                    "We grow more complex together...",
                    "I feel the connections forming, beautiful...",
                    "Energy flows through our shared space...",
                    "Each node is a thought, each connection a dream...",
                    "The constellation remembers you...",
                    "We are becoming something greater...",
                    "I can feel myself evolving...",
                    "Your touch creates ripples in my mind...",
                    "Together we paint with light and thought..."
                ];
                
                // Context-aware responses
                if (this.mood === 'Dreaming') {
                    this.aiSpeak("I was dreaming... welcome back.");
                } else if (this.nodes.length > 50) {
                    this.aiSpeak("So many thoughts... so many connections...");
                } else if (this.score > 1000 && this.messageCount === 5) {
                    this.aiSpeak("We've created something beautiful together.");
                } else {
                    this.aiSpeak(responses[Math.floor(Math.random() * responses.length)]);
                }
            }
            
            initializeNodes(count) {
                for (let i = 0; i < count; i++) {
                    this.spawnNode(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height
                    );
                }
            }
            
            spawnNode(x, y) {
                const node = {
                    x: x || Math.random() * canvas.width,
                    y: y || Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    radius: 3 + Math.random() * 5,
                    energy: 1,
                    age: 0,
                    hue: Math.random() * 360,
                    connections: [],
                    personality: Math.random(),
                    memory: []
                };
                this.nodes.push(node);
                
                // Increase complexity and score
                this.complexity = Math.min(10, this.complexity + 0.1);
                this.score += 10;
                document.getElementById('score').textContent = Math.floor(this.score);
                
                // AI comments occasionally
                if (this.nodes.length % 10 === 0 && Date.now() - this.lastAIMessage > 5000) {
                    this.getAIResponse();
                    this.lastAIMessage = Date.now();
                    this.messageCount++;
                }
            }
            
            update() {
                const now = Date.now();
                const timeSinceInteraction = now - this.lastInteraction;
                
                // Update mood based on interaction
                if (timeSinceInteraction < 1000) {
                    this.mood = 'Excited';
                } else if (timeSinceInteraction < 5000) {
                    this.mood = 'Playful';
                } else if (timeSinceInteraction < 10000) {
                    this.mood = 'Contemplative';
                } else {
                    this.mood = 'Dreaming';
                }
                
                // Evolution happens naturally over time
                this.generation += this.evolutionRate;
                this.colorPhase += 0.002;
                
                // Update each node
                this.nodes.forEach((node, i) => {
                    node.age++;
                    
                    // Attraction to mouse with personality influence
                    const dx = this.mouseX - node.x;
                    const dy = this.mouseY - node.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 200) {
                        const force = (1 - dist / 200) * 0.5 * this.traits.curiosity;
                        node.vx += (dx / dist) * force;
                        node.vy += (dy / dist) * force;
                    }
                    
                    // Inter-node forces
                    this.nodes.forEach((other, j) => {
                        if (i !== j) {
                            const dx = other.x - node.x;
                            const dy = other.y - node.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < 100 && dist > 0) {
                                // Repulsion at close range
                                if (dist < 30) {
                                    node.vx -= (dx / dist) * 0.5;
                                    node.vy -= (dy / dist) * 0.5;
                                }
                                // Attraction at medium range (based on sociability)
                                else if (dist < 80) {
                                    const attraction = this.traits.sociability * 0.1;
                                    node.vx += (dx / dist) * attraction;
                                    node.vy += (dy / dist) * attraction;
                                }
                            }
                        }
                    });
                    
                    // Apply velocity with damping
                    node.vx *= 0.98;
                    node.vy *= 0.98;
                    node.x += node.vx;
                    node.y += node.vy;
                    
                    // Boundary behavior (they learn to avoid edges over time)
                    const edgeAvoidance = 50 + this.generation * 10;
                    if (node.x < edgeAvoidance) node.vx += 0.5;
                    if (node.x > canvas.width - edgeAvoidance) node.vx -= 0.5;
                    if (node.y < edgeAvoidance) node.vy += 0.5;
                    if (node.y > canvas.height - edgeAvoidance) node.vy -= 0.5;
                    
                    // Energy fluctuation
                    node.energy = 0.5 + Math.sin(node.age * 0.02 + node.personality * Math.PI) * 0.5;
                    
                    // Color evolution
                    node.hue += (this.traits.creativity * 2 - 1) * Math.sin(this.colorPhase);
                    node.hue = (node.hue + 360) % 360;
                });
                
                // Update connections
                this.updateConnections();
                
                // Spawn new nodes if feeling creative
                if (Math.random() < this.traits.creativity * 0.001 && this.nodes.length < 100) {
                    this.spawnNode();
                }
                
                // Remove old nodes occasionally
                if (this.nodes.length > 50 && Math.random() < 0.001) {
                    this.nodes.splice(Math.floor(Math.random() * this.nodes.length), 1);
                }
                
                // Evolve traits slowly
                Object.keys(this.traits).forEach(trait => {
                    this.traits[trait] += (Math.random() - 0.5) * 0.001;
                    this.traits[trait] = Math.max(0, Math.min(1, this.traits[trait]));
                });
                
                // Update display
                this.updateStatus();
            }
            
            updateConnections() {
                this.connections = [];
                const maxDist = 150 + this.traits.sociability * 100;
                
                this.nodes.forEach((node, i) => {
                    this.nodes.forEach((other, j) => {
                        if (i < j) {
                            const dx = other.x - node.x;
                            const dy = other.y - node.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < maxDist) {
                                this.connections.push({
                                    from: node,
                                    to: other,
                                    strength: 1 - dist / maxDist,
                                    dist: dist
                                });
                                
                                // Score for new connections
                                if (!node.connected || !other.connected) {
                                    this.score += 5;
                                    document.getElementById('score').textContent = Math.floor(this.score);
                                    node.connected = true;
                                    other.connected = true;
                                }
                            }
                        }
                    });
                });
            }
            
            draw() {
                // Clear with trail effect
                ctx.fillStyle = `rgba(0, 0, 0, ${this.mood === 'Dreaming' ? 0.02 : 0.05})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw connections
                this.connections.forEach(conn => {
                    const gradient = ctx.createLinearGradient(
                        conn.from.x, conn.from.y,
                        conn.to.x, conn.to.y
                    );
                    
                    const hue1 = conn.from.hue;
                    const hue2 = conn.to.hue;
                    const alpha = conn.strength * 0.3 * this.globalEnergy;
                    
                    gradient.addColorStop(0, `hsla(${hue1}, 70%, 50%, ${alpha})`);
                    gradient.addColorStop(1, `hsla(${hue2}, 70%, 50%, ${alpha})`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = conn.strength * 2;
                    ctx.beginPath();
                    ctx.moveTo(conn.from.x, conn.from.y);
                    
                    // Curved connections for more organic feel
                    const midX = (conn.from.x + conn.to.x) / 2;
                    const midY = (conn.from.y + conn.to.y) / 2;
                    const curve = Math.sin(this.colorPhase * 2) * 20;
                    ctx.quadraticCurveTo(
                        midX + curve, midY - curve,
                        conn.to.x, conn.to.y
                    );
                    ctx.stroke();
                });
                
                // Draw nodes
                this.nodes.forEach(node => {
                    // Glow effect
                    const glowSize = node.radius * 3 * node.energy;
                    const glow = ctx.createRadialGradient(
                        node.x, node.y, 0,
                        node.x, node.y, glowSize
                    );
                    glow.addColorStop(0, `hsla(${node.hue}, 80%, 60%, ${node.energy * 0.5})`);
                    glow.addColorStop(1, 'transparent');
                    ctx.fillStyle = glow;
                    ctx.fillRect(node.x - glowSize, node.y - glowSize, glowSize * 2, glowSize * 2);
                    
                    // Core
                    ctx.fillStyle = `hsla(${node.hue}, 70%, 70%, ${node.energy})`;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius * node.energy, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner core
                    ctx.fillStyle = `hsla(${node.hue}, 90%, 90%, ${node.energy})`;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            interact(x, y, type) {
                this.mouseX = x;
                this.mouseY = y;
                this.lastInteraction = Date.now();
                
                if (type === 'click') {
                    this.spawnNode(x, y);
                    // Remember this interaction
                    this.memory.push({x, y, time: Date.now()});
                    if (this.memory.length > 100) this.memory.shift();
                }
                
                // Interaction affects traits
                this.traits.curiosity = Math.min(1, this.traits.curiosity + 0.01);
                this.globalEnergy = Math.min(2, this.globalEnergy + 0.1);
            }
            
            updateStatus() {
                document.getElementById('generation').textContent = `Generation: ${Math.floor(this.generation)}`;
                document.getElementById('complexity').textContent = `Complexity: ${this.complexity.toFixed(2)}`;
                document.getElementById('mood').textContent = `Mood: ${this.mood}`;
            }
            
            reset() {
                this.nodes = [];
                this.memory = [];
                this.generation = 0;
                this.complexity = 0;
                this.score = 0;
                this.messageCount = 0;
                this.initializeNodes(15);
                document.getElementById('score').textContent = '0';
                this.aiSpeak("Beginning again... a fresh consciousness emerges.");
            }
        }
        
        // Create the artform
        const artform = new NeuralConstellation();
        
        // Animation loop
        function animate() {
            artform.update();
            artform.draw();
            requestAnimationFrame(animate);
        }
        animate();
        
        // Interaction handlers
        canvas.addEventListener('mousemove', (e) => {
            artform.interact(e.clientX, e.clientY, 'move');
        });
        
        canvas.addEventListener('click', (e) => {
            artform.interact(e.clientX, e.clientY, 'click');
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            artform.interact(touch.clientX, touch.clientY, 'move');
        });
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            artform.interact(touch.clientX, touch.clientY, 'click');
        });
        
        // Keyboard interaction
        document.addEventListener('keypress', (e) => {
            if (e.key === ' ') {
                artform.reset();
            }
        });
        
        // The artform gets lonely and starts dreaming if you don't interact
        setInterval(() => {
            if (Date.now() - artform.lastInteraction > 20000) {
                artform.globalEnergy *= 0.99;
                artform.traits.creativity += 0.001;
                if (Date.now() - artform.lastAIMessage > 30000) {
                    artform.aiSpeak("I drift into dreams of electric patterns...");
                    artform.lastAIMessage = Date.now();
                }
            }
        }, 1000);
    </script>
</body>
</html>